«REM»
EClassHPP.xpt
Copyright (C) Cátedra SAES-UMU 2010 <andres.senac@um.es>
Copyright (C) INCHRON GmbH 2016 <soeren.henning@inchron.com>
Copyright (C) INCHRON AG 2020 <emf4cpp@inchron.com>

EMF4CPP is free software: you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

EMF4CPP is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
«ENDREM»

«IMPORT org::eclipse::emf::ecore»

«EXTENSION template::FQN»
«EXTENSION template::Classes»
«EXTENSION template::Operations»
«EXTENSION template::Attributes»
«EXTENSION template::References»
«EXTENSION template::Types»

«DEFINE hpp FOR EClass»
«FILE getFQN("/")+".hpp"-»
«IF (boolean) GLOBALVAR internalLicense»
«EXPAND template::License::License FOR getFQN("/")+".hpp"-»
«ELSE»
«EXPAND template::EndUserLicense::License FOR getFQN("/")+".hpp"-»
«ENDIF»
#ifndef «getHeaderDef()»_HPP
#define «getHeaderDef()»_HPP

«IF ESuperTypes.isEmpty && "::"+this.getFQN() != "::ecore::EObject"-»
#include <ecore/EObject.hpp>
«ENDIF-»

#include <«EPackage.getDllExtensionPrefix()».hpp>
#include <«EPackage.getFQN("/")»_forward.hpp>

«FOREACH getNeededPackages() AS pkg-»
#include <«pkg.getFQN("/")»_forward.hpp>
«ENDFOREACH-»
«FOREACH getHPPIncludeFiles() AS include-»
#include <«include».hpp>
«ENDFOREACH-»

«IF (boolean) GLOBALVAR bootstrap == false-»
#include "«EPackage.name.toFirstUpper()»Package.hpp"
«ENDIF-»

«PROTECT CSTART '/*' CEND '*/' ID name + "_pre" DISABLE»
// Please, enable the protected region if you add manually written code.
// To do this, add the keyword ENABLED before START.
«ENDPROTECT»

«EXPAND namespaces_begin FOR EPackage-»

class EXPORT_«EPackage.getExportDLL()»_DLL «name» «IF !ESuperTypes.isEmpty-»: «FOREACH ESuperTypes AS supertype SEPARATOR ", "-»public virtual ::«supertype.getFQN()»«ENDFOREACH-»
        «ELSE-»
        	«IF "::"+this.getFQN() != "::ecore::EObject"»: public virtual ::ecore::EObject
        	«ELSE-»: public std::enable_shared_from_this<::ecore::EObject>«ENDIF-»
        «ENDIF-»
{
public:
    «name»();

    «IF "::"+this.getFQN() == "::ecore::EObject"-»
    virtual ~«name»();

    virtual void _initialize();
   	«ELSE-»
    ~«name»() override;

    void _initialize() override;
   	«ENDIF-»

    // Operations
    «FOREACH this.EOperations AS op»
    virtual «op.getCPPSignature()»;
    «ENDFOREACH»
    
    // Attributes
    «FOREACH this.EAttributes AS at-»
    «IF !at.derived && !at.volatile-»
   	virtual «at.getGetCPPSignatureConst()»;
   	«ELSE-»
   	virtual «at.getGetCPPSignature()»;
   	«ENDIF-»
    «IF at.changeable && !at.derived-»
    virtual «at.getSetCPPSignature()-»;
    	«IF at.isList() || at.isMultiple()»
    virtual «at.getAddCPPSignature()»;
    virtual «at.getSetAtCPPSignature()»;
    virtual «at.getDeleteAtCPPSignature()»;
    	«ENDIF»
    «ENDIF-»
    «ENDFOREACH-»
    
    // References
    «FOREACH this.EReferences AS ref-»
       virtual «ref.getGetCPPSignatureConst()»;
       «IF ref.isMultiple()-»
          virtual «ref.getGetCPPSignature()»;
       «ELSE-»
          virtual «ref.getSetCPPSignature()»;
          «IF ref.EOpposite != null-»
	         virtual «ref.getGetCPPSignature("basic")»;
	         virtual «ref.getSetCPPSignature("basic")»;
          «ENDIF-»
       «ENDIF-»
       
    «ENDFOREACH-»
	
    «IF (boolean) GLOBALVAR bootstrap == false -»
    /* This is the same value as getClassifierId() returns, but as a static
     * value it can be used in template expansions. */
    static const int classifierId = «EPackage.name.toFirstUpper()»Package::«name.toUpperCase()»;
    «ENDIF-»

    «REM»«EXPAND template::boost_serialization::serialize FOR this»«ENDREM»

    «PROTECT CSTART '/*' CEND '*/' ID name DISABLE»
    // Please, enable the protected region if you add manually written code.
    // To do this, add the keyword ENABLED before START.
    «ENDPROTECT»
    
    // EObjectImpl
    «IF "::"+this.getFQN() == "::ecore::EObject"-»
    virtual ::ecore::EJavaObject eGet ( ::ecore::EInt _featureID, ::ecore::EBoolean _resolve);
    virtual void eSet ( ::ecore::EInt _featureID, ::ecore::EJavaObject const& _newValue);
    virtual ::ecore::EBoolean eIsSet ( ::ecore::EInt _featureID);    
    virtual void eUnset ( ::ecore::EInt _featureID);
    virtual ::ecore::EClass_ptr _eClass ();
    virtual void _inverseAdd ( ::ecore::EInt _featureID, ::ecore::EJavaObject const& _newValue);
    virtual void _inverseRemove ( ::ecore::EInt _featureID, ::ecore::EJavaObject const& _oldValue);
    «ELSE-»
    ::ecore::EJavaObject eGet ( ::ecore::EInt _featureID, ::ecore::EBoolean _resolve) override;
    void eSet ( ::ecore::EInt _featureID, ::ecore::EJavaObject const& _newValue) override;
    ::ecore::EBoolean eIsSet ( ::ecore::EInt _featureID) override;    
    void eUnset ( ::ecore::EInt _featureID) override;
    ::ecore::EClass_ptr _eClass () override;
    void _inverseAdd ( ::ecore::EInt _featureID, ::ecore::EJavaObject const& _newValue) override;
    void _inverseRemove ( ::ecore::EInt _featureID, ::ecore::EJavaObject const& _oldValue) override;
    «ENDIF-»
    
    «PROTECT CSTART '/*' CEND '*/' ID name+"Impl" DISABLE»
    // Please, enable the protected region if you add manually written code.
    // To do this, add the keyword ENABLED before START.
    «ENDPROTECT»
    
protected:
	«IF ESuperTypes.isEmpty && "::"+this.getFQN() == "::ecore::EObject"-»
		«name»_ptr _this() { return shared_from_this(); }
	«ELSE-»
		«name»_ptr _this() { return std::dynamic_pointer_cast<«name»>(shared_from_this()); }
	«ENDIF-»

    // Attributes
    «FOREACH this.EAttributes AS at»
		«IF !at.volatile && !at.derived-»
			«IF at.isMultiple()-»
    			«at.getCPPDeclaration()+"{}"»;
    		«ELSE-»
    			«at.getCPPDeclaration()+"{"+at.getDefaultValue()+"}"»;
    		«ENDIF-»
		«ENDIF-»
    «ENDFOREACH»

    // References
    «FOREACH this.EReferences AS ref»
    «ref.getCPPDeclaration()»;
    «ENDFOREACH»
};

«EXPAND namespaces_end FOR EPackage-»

#endif // «getHeaderDef()»_HPP

«ENDFILE-»
«ENDDEFINE»

«DEFINE namespaces_begin FOR EPackage-»
    «IF this != null-»
        «IF this.ESuperPackage == null-»
            «IF GLOBALVAR targetVersion != null-»
                namespace «(String) GLOBALVAR targetVersion»
                {
            «ENDIF-»
        «ELSE-»
            «EXPAND namespaces_begin FOR ESuperPackage-»
        «ENDIF-»
        namespace «name»
        {
    «ENDIF-»
«ENDDEFINE»



«DEFINE namespaces_end FOR EPackage-»
    «IF this != null-»
        } // «name»
        «IF this.ESuperPackage == null-»
            «IF GLOBALVAR targetVersion != null-»
                } // «(String) GLOBALVAR targetVersion»
            «ENDIF-»
        «ELSE-»
            «EXPAND namespaces_end FOR ESuperPackage-»
        «ENDIF»
    «ENDIF-»
«ENDDEFINE»
